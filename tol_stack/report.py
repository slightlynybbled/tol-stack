from io import BytesIO
from datetime import datetime

from fpdf import FPDF

from tol_stack.stack import StackPath
from tol_stack.version import __version__


class StackupReport(FPDF):
    def __init__(self, stackpath: StackPath):
        super().__init__()

        self.font_name = 'helvetica'
        self.stackpath = stackpath

        # title page
        self.add_page()
        self.set_font(self.font_name, 'B', 16)
        self.cell(185, 10, f'{stackpath.name}')

        self.set_font(self.font_name, '', 12)
        self.ln(20)
        self.multi_cell(185, 10, f'Report generated by Tolerence Stack Analyzer v{__version__} on {datetime.now()}', ln=2)

        if self.stackpath.description is not None:
            self.ln(10)
            self.multi_cell(185, 10, f'{self.stackpath.description}', ln=1)

        if self.stackpath.images is not None:
            for image in self.stackpath.images:
                self.ln()
                self.image(image)

        # create a part-by-part max/min length analysis,
        # including comments, pictures, and distributions
        for part in self.stackpath.parts:
            self.add_page()
            self.set_font(self.font_name, "B", 14)
            self.cell(185, 10, f'{part.name}', ln=1)

            self.set_font(self.font_name, "", 14)
            if part.nominal_length is not None:
                self.cell(185, 10, f'nominal length: {part.nominal_length}', ln=1)
            if part.tolerance is not None:
                self.cell(185, 10, f'tolerance: {part.tolerance}', ln=1)

            if part.images is not None:
                for image in part.images:
                    self.ln()
                    self.image(image)

            if part.comment is not None:
                self.cell(185, 10, f'{part.comment}', ln=1)

            # show part distribution
            buffer = BytesIO()
            fig = part.show_length_dist()
            fig.savefig(buffer, format='png')
            self.ln()
            self.image(buffer, w=self.epw)

        # todo: create stack path analysis
        buffer = BytesIO()
        fig = self.stackpath.show_length_dist()
        fig.savefig(buffer, format='png')
        self.ln()
        self.image(buffer, w=self.epw)

        self.output(f'{self.stackpath.name}.pdf')






